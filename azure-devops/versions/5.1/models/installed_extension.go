// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InstalledExtension Represents a VSTS extension along with its installation state
// swagger:model InstalledExtension
type InstalledExtension struct {
	ExtensionManifest

	// The friendly extension id for this extension - unique for a given publisher.
	ExtensionID string `json:"extensionId,omitempty"`

	// The display name of the extension.
	ExtensionName string `json:"extensionName,omitempty"`

	// This is the set of files available from the extension.
	Files []*ExtensionFile `json:"files"`

	// Extension flags relevant to contribution consumers
	// Enum: [builtIn trusted]
	Flags interface{} `json:"flags,omitempty"`

	// Information about this particular installation of the extension
	InstallState *InstalledExtensionState `json:"installState,omitempty"`

	// This represents the date/time the extensions was last updated in the gallery. This doesnt mean this version was updated the value represents changes to any and all versions of the extension.
	// Format: date-time
	LastPublished strfmt.DateTime `json:"lastPublished,omitempty"`

	// Unique id of the publisher of this extension
	PublisherID string `json:"publisherId,omitempty"`

	// The display name of the publisher
	PublisherName string `json:"publisherName,omitempty"`

	// Unique id for this extension (the same id is used for all versions of a single extension)
	// Format: uuid
	RegistrationID strfmt.UUID `json:"registrationId,omitempty"`

	// Version of this extension
	Version string `json:"version,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *InstalledExtension) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 ExtensionManifest
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.ExtensionManifest = aO0

	// now for regular properties
	var propsInstalledExtension struct {
		ExtensionID string `json:"extensionId,omitempty"`

		ExtensionName string `json:"extensionName,omitempty"`

		Files []*ExtensionFile `json:"files"`

		Flags interface{} `json:"flags,omitempty"`

		InstallState *InstalledExtensionState `json:"installState,omitempty"`

		LastPublished strfmt.DateTime `json:"lastPublished,omitempty"`

		PublisherID string `json:"publisherId,omitempty"`

		PublisherName string `json:"publisherName,omitempty"`

		RegistrationID strfmt.UUID `json:"registrationId,omitempty"`

		Version string `json:"version,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsInstalledExtension); err != nil {
		return err
	}
	m.ExtensionID = propsInstalledExtension.ExtensionID

	m.ExtensionName = propsInstalledExtension.ExtensionName

	m.Files = propsInstalledExtension.Files

	m.Flags = propsInstalledExtension.Flags

	m.InstallState = propsInstalledExtension.InstallState

	m.LastPublished = propsInstalledExtension.LastPublished

	m.PublisherID = propsInstalledExtension.PublisherID

	m.PublisherName = propsInstalledExtension.PublisherName

	m.RegistrationID = propsInstalledExtension.RegistrationID

	m.Version = propsInstalledExtension.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m InstalledExtension) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(m.ExtensionManifest)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	// now for regular properties
	var propsInstalledExtension struct {
		ExtensionID string `json:"extensionId,omitempty"`

		ExtensionName string `json:"extensionName,omitempty"`

		Files []*ExtensionFile `json:"files"`

		Flags interface{} `json:"flags,omitempty"`

		InstallState *InstalledExtensionState `json:"installState,omitempty"`

		LastPublished strfmt.DateTime `json:"lastPublished,omitempty"`

		PublisherID string `json:"publisherId,omitempty"`

		PublisherName string `json:"publisherName,omitempty"`

		RegistrationID strfmt.UUID `json:"registrationId,omitempty"`

		Version string `json:"version,omitempty"`
	}
	propsInstalledExtension.ExtensionID = m.ExtensionID

	propsInstalledExtension.ExtensionName = m.ExtensionName

	propsInstalledExtension.Files = m.Files

	propsInstalledExtension.Flags = m.Flags

	propsInstalledExtension.InstallState = m.InstallState

	propsInstalledExtension.LastPublished = m.LastPublished

	propsInstalledExtension.PublisherID = m.PublisherID

	propsInstalledExtension.PublisherName = m.PublisherName

	propsInstalledExtension.RegistrationID = m.RegistrationID

	propsInstalledExtension.Version = m.Version

	jsonDataPropsInstalledExtension, errInstalledExtension := swag.WriteJSON(propsInstalledExtension)
	if errInstalledExtension != nil {
		return nil, errInstalledExtension
	}
	_parts = append(_parts, jsonDataPropsInstalledExtension)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this installed extension
func (m *InstalledExtension) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with ExtensionManifest
	if err := m.ExtensionManifest.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstallState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastPublished(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegistrationID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InstalledExtension) validateFiles(formats strfmt.Registry) error {

	if swag.IsZero(m.Files) { // not required
		return nil
	}

	for i := 0; i < len(m.Files); i++ {
		if swag.IsZero(m.Files[i]) { // not required
			continue
		}

		if m.Files[i] != nil {
			if err := m.Files[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InstalledExtension) validateInstallState(formats strfmt.Registry) error {

	if swag.IsZero(m.InstallState) { // not required
		return nil
	}

	if m.InstallState != nil {
		if err := m.InstallState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("installState")
			}
			return err
		}
	}

	return nil
}

func (m *InstalledExtension) validateLastPublished(formats strfmt.Registry) error {

	if swag.IsZero(m.LastPublished) { // not required
		return nil
	}

	if err := validate.FormatOf("lastPublished", "body", "date-time", m.LastPublished.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InstalledExtension) validateRegistrationID(formats strfmt.Registry) error {

	if swag.IsZero(m.RegistrationID) { // not required
		return nil
	}

	if err := validate.FormatOf("registrationId", "body", "uuid", m.RegistrationID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InstalledExtension) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InstalledExtension) UnmarshalBinary(b []byte) error {
	var res InstalledExtension
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
