// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// WidgetMetadata Contribution based information describing Dashboard Widgets.
// swagger:model WidgetMetadata
type WidgetMetadata struct {

	// Sizes supported by the Widget.
	AllowedSizes []*WidgetSize `json:"allowedSizes"`

	// Opt-in boolean that indicates if the widget requires the Analytics Service to function. Widgets requiring the analytics service are hidden from the catalog if the Analytics Service is not available.
	AnalyticsServiceRequired bool `json:"analyticsServiceRequired,omitempty"`

	// Resource for an icon in the widget catalog.
	CatalogIconURL string `json:"catalogIconUrl,omitempty"`

	// Opt-in URL string pointing at widget information. Defaults to extension marketplace URL if omitted
	CatalogInfoURL string `json:"catalogInfoUrl,omitempty"`

	// The id of the underlying contribution defining the supplied Widget custom configuration UI. Null if custom configuration UI is not available.
	ConfigurationContributionID string `json:"configurationContributionId,omitempty"`

	// The relative id of the underlying contribution defining the supplied Widget custom configuration UI. Null if custom configuration UI is not available.
	ConfigurationContributionRelativeID string `json:"configurationContributionRelativeId,omitempty"`

	// Indicates if the widget requires configuration before being added to dashboard.
	ConfigurationRequired bool `json:"configurationRequired,omitempty"`

	// Uri for the widget content to be loaded from .
	ContentURI string `json:"contentUri,omitempty"`

	// The id of the underlying contribution defining the supplied Widget.
	ContributionID string `json:"contributionId,omitempty"`

	// Optional default settings to be copied into widget settings.
	DefaultSettings string `json:"defaultSettings,omitempty"`

	// Summary information describing the widget.
	Description string `json:"description,omitempty"`

	// Widgets can be disabled by the app store.  We'll need to gracefully handle for: - persistence (Allow) - Requests (Tag as disabled, and provide context)
	IsEnabled bool `json:"isEnabled,omitempty"`

	// Opt-out boolean that indicates if the widget supports widget name/title configuration. Widgets ignoring the name should set it to false in the manifest.
	IsNameConfigurable bool `json:"isNameConfigurable,omitempty"`

	// Opt-out boolean indicating if the widget is hidden from the catalog. Commonly, this is used to allow developers to disable creation of a deprecated widget. A widget must have a functional default state, or have a configuration experience, in order to be visible from the catalog.
	IsVisibleFromCatalog bool `json:"isVisibleFromCatalog,omitempty"`

	// Opt-in properties for customizing widget presentation in a "lightbox" dialog.
	LightboxOptions *LightboxOptions `json:"lightboxOptions,omitempty"`

	// Resource for a loading placeholder image on dashboard
	LoadingImageURL string `json:"loadingImageUrl,omitempty"`

	// User facing name of the widget type. Each widget must use a unique value here.
	Name string `json:"name,omitempty"`

	// Publisher Name of this kind of widget.
	PublisherName string `json:"publisherName,omitempty"`

	// Data contract required for the widget to function and to work in its container.
	SupportedScopes []interface{} `json:"supportedScopes"`

	// Contribution target IDs
	Targets []string `json:"targets"`

	// Deprecated: locally unique developer-facing id of this kind of widget. ContributionId provides a globally unique identifier for widget types.
	TypeID string `json:"typeId,omitempty"`
}

// Validate validates this widget metadata
func (m *WidgetMetadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAllowedSizes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLightboxOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedScopes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *WidgetMetadata) validateAllowedSizes(formats strfmt.Registry) error {

	if swag.IsZero(m.AllowedSizes) { // not required
		return nil
	}

	for i := 0; i < len(m.AllowedSizes); i++ {
		if swag.IsZero(m.AllowedSizes[i]) { // not required
			continue
		}

		if m.AllowedSizes[i] != nil {
			if err := m.AllowedSizes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("allowedSizes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *WidgetMetadata) validateLightboxOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.LightboxOptions) { // not required
		return nil
	}

	if m.LightboxOptions != nil {
		if err := m.LightboxOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lightboxOptions")
			}
			return err
		}
	}

	return nil
}

var widgetMetadataSupportedScopesItemsEnum []interface{}

func init() {
	var res []interface{}
	if err := json.Unmarshal([]byte(`["collection_User","project_Team"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		widgetMetadataSupportedScopesItemsEnum = append(widgetMetadataSupportedScopesItemsEnum, v)
	}
}

func (m *WidgetMetadata) validateSupportedScopesItemsEnum(path, location string, value interface{}) error {
	if err := validate.Enum(path, location, value, widgetMetadataSupportedScopesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *WidgetMetadata) validateSupportedScopes(formats strfmt.Registry) error {

	if swag.IsZero(m.SupportedScopes) { // not required
		return nil
	}

	return nil
}

// MarshalBinary interface implementation
func (m *WidgetMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *WidgetMetadata) UnmarshalBinary(b []byte) error {
	var res WidgetMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
