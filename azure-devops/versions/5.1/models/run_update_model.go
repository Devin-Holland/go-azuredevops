// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// RunUpdateModel run update model
// swagger:model RunUpdateModel
type RunUpdateModel struct {

	// An abstracted reference to the build that it belongs.
	Build *ShallowReference `json:"build,omitempty"`

	// Drop location of the build used for test run.
	BuildDropLocation string `json:"buildDropLocation,omitempty"`

	// Flavor of the build used for test run. (E.g: Release, Debug)
	BuildFlavor string `json:"buildFlavor,omitempty"`

	// Platform of the build used for test run. (E.g.: x86, amd64)
	BuildPlatform string `json:"buildPlatform,omitempty"`

	// Comments entered by those analyzing the run.
	Comment string `json:"comment,omitempty"`

	// Completed date time of the run.
	CompletedDate string `json:"completedDate,omitempty"`

	// Name of the test controller used for automated run.
	Controller string `json:"controller,omitempty"`

	// true to delete inProgess Results , false otherwise.
	DeleteInProgressResults bool `json:"deleteInProgressResults,omitempty"`

	// An abstracted reference to DtlAutEnvironment.
	DtlAutEnvironment *ShallowReference `json:"dtlAutEnvironment,omitempty"`

	// An abstracted reference to DtlEnvironment.
	DtlEnvironment *ShallowReference `json:"dtlEnvironment,omitempty"`

	// dtl environment details
	DtlEnvironmentDetails *DtlEnvironmentDetails `json:"dtlEnvironmentDetails,omitempty"`

	// Due date and time for test run.
	DueDate string `json:"dueDate,omitempty"`

	// Error message associated with the run.
	ErrorMessage string `json:"errorMessage,omitempty"`

	// The iteration in which to create the run.
	Iteration string `json:"iteration,omitempty"`

	// Log entries associated with the run. Use a comma-separated list of multiple log entry objects. { logEntry }, { logEntry }, ...
	LogEntries []*TestMessageLogDetails `json:"logEntries"`

	// Name of the test run.
	Name string `json:"name,omitempty"`

	// URI of release environment associated with the run.
	ReleaseEnvironmentURI string `json:"releaseEnvironmentUri,omitempty"`

	// URI of release associated with the run.
	ReleaseURI string `json:"releaseUri,omitempty"`

	// Run summary for run Type = NoConfigRun.
	RunSummary []*RunSummaryModel `json:"runSummary"`

	// SourceWorkFlow(CI/CD) of the test run.
	SourceWorkflow string `json:"sourceWorkflow,omitempty"`

	// Start date time of the run.
	StartedDate string `json:"startedDate,omitempty"`

	// The state of the test run Below are the valid values - NotStarted, InProgress, Completed, Aborted, Waiting
	State string `json:"state,omitempty"`

	// The types of sub states for test run.
	// Enum: [none creatingEnvironment runningTests canceledByUser abortedBySystem timedOut pendingAnalysis analyzed cancellationInProgress]
	Substate interface{} `json:"substate,omitempty"`

	// Tags to attach with the test run.
	Tags []*TestTag `json:"tags"`

	// ID of the test environment associated with the run.
	TestEnvironmentID string `json:"testEnvironmentId,omitempty"`

	// An abstracted reference to test setting resource.
	TestSettings *ShallowReference `json:"testSettings,omitempty"`
}

// Validate validates this run update model
func (m *RunUpdateModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuild(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDtlAutEnvironment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDtlEnvironment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDtlEnvironmentDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogEntries(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTestSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RunUpdateModel) validateBuild(formats strfmt.Registry) error {

	if swag.IsZero(m.Build) { // not required
		return nil
	}

	if m.Build != nil {
		if err := m.Build.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("build")
			}
			return err
		}
	}

	return nil
}

func (m *RunUpdateModel) validateDtlAutEnvironment(formats strfmt.Registry) error {

	if swag.IsZero(m.DtlAutEnvironment) { // not required
		return nil
	}

	if m.DtlAutEnvironment != nil {
		if err := m.DtlAutEnvironment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dtlAutEnvironment")
			}
			return err
		}
	}

	return nil
}

func (m *RunUpdateModel) validateDtlEnvironment(formats strfmt.Registry) error {

	if swag.IsZero(m.DtlEnvironment) { // not required
		return nil
	}

	if m.DtlEnvironment != nil {
		if err := m.DtlEnvironment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dtlEnvironment")
			}
			return err
		}
	}

	return nil
}

func (m *RunUpdateModel) validateDtlEnvironmentDetails(formats strfmt.Registry) error {

	if swag.IsZero(m.DtlEnvironmentDetails) { // not required
		return nil
	}

	if m.DtlEnvironmentDetails != nil {
		if err := m.DtlEnvironmentDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dtlEnvironmentDetails")
			}
			return err
		}
	}

	return nil
}

func (m *RunUpdateModel) validateLogEntries(formats strfmt.Registry) error {

	if swag.IsZero(m.LogEntries) { // not required
		return nil
	}

	for i := 0; i < len(m.LogEntries); i++ {
		if swag.IsZero(m.LogEntries[i]) { // not required
			continue
		}

		if m.LogEntries[i] != nil {
			if err := m.LogEntries[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("logEntries" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RunUpdateModel) validateRunSummary(formats strfmt.Registry) error {

	if swag.IsZero(m.RunSummary) { // not required
		return nil
	}

	for i := 0; i < len(m.RunSummary); i++ {
		if swag.IsZero(m.RunSummary[i]) { // not required
			continue
		}

		if m.RunSummary[i] != nil {
			if err := m.RunSummary[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("runSummary" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RunUpdateModel) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	for i := 0; i < len(m.Tags); i++ {
		if swag.IsZero(m.Tags[i]) { // not required
			continue
		}

		if m.Tags[i] != nil {
			if err := m.Tags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RunUpdateModel) validateTestSettings(formats strfmt.Registry) error {

	if swag.IsZero(m.TestSettings) { // not required
		return nil
	}

	if m.TestSettings != nil {
		if err := m.TestSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("testSettings")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RunUpdateModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RunUpdateModel) UnmarshalBinary(b []byte) error {
	var res RunUpdateModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
