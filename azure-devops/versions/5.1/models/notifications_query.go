// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NotificationsQuery Defines a query for service hook notifications.
// swagger:model NotificationsQuery
type NotificationsQuery struct {

	// The subscriptions associated with the notifications returned from the query
	AssociatedSubscriptions []*Subscription `json:"associatedSubscriptions"`

	// If true, we will return all notification history for the query provided; otherwise, the summary is returned.
	IncludeDetails bool `json:"includeDetails,omitempty"`

	// Optional maximum date at which the notification was created
	// Format: date-time
	MaxCreatedDate strfmt.DateTime `json:"maxCreatedDate,omitempty"`

	// Optional maximum number of overall results to include
	MaxResults int32 `json:"maxResults,omitempty"`

	// Optional maximum number of results for each subscription. Only takes effect when a list of subscription ids is supplied in the query.
	MaxResultsPerSubscription int32 `json:"maxResultsPerSubscription,omitempty"`

	// Optional minimum date at which the notification was created
	// Format: date-time
	MinCreatedDate strfmt.DateTime `json:"minCreatedDate,omitempty"`

	// Optional publisher id to restrict the results to
	PublisherID string `json:"publisherId,omitempty"`

	// Optional notification result type to filter results to
	// Enum: [pending succeeded failed filtered]
	ResultType interface{} `json:"resultType,omitempty"`

	// Results from the query
	Results []*Notification `json:"results"`

	// Optional notification status to filter results to
	// Enum: [queued processing requestInProgress completed]
	Status interface{} `json:"status,omitempty"`

	// Optional list of subscription ids to restrict the results to
	SubscriptionIds []strfmt.UUID `json:"subscriptionIds"`

	// Summary of notifications - the count of each result type (success, fail, ..).
	Summary []*NotificationSummary `json:"summary"`
}

// Validate validates this notifications query
func (m *NotificationsQuery) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssociatedSubscriptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResults(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NotificationsQuery) validateAssociatedSubscriptions(formats strfmt.Registry) error {

	if swag.IsZero(m.AssociatedSubscriptions) { // not required
		return nil
	}

	for i := 0; i < len(m.AssociatedSubscriptions); i++ {
		if swag.IsZero(m.AssociatedSubscriptions[i]) { // not required
			continue
		}

		if m.AssociatedSubscriptions[i] != nil {
			if err := m.AssociatedSubscriptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("associatedSubscriptions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NotificationsQuery) validateMaxCreatedDate(formats strfmt.Registry) error {

	if swag.IsZero(m.MaxCreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("maxCreatedDate", "body", "date-time", m.MaxCreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *NotificationsQuery) validateMinCreatedDate(formats strfmt.Registry) error {

	if swag.IsZero(m.MinCreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("minCreatedDate", "body", "date-time", m.MinCreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *NotificationsQuery) validateResults(formats strfmt.Registry) error {

	if swag.IsZero(m.Results) { // not required
		return nil
	}

	for i := 0; i < len(m.Results); i++ {
		if swag.IsZero(m.Results[i]) { // not required
			continue
		}

		if m.Results[i] != nil {
			if err := m.Results[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("results" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NotificationsQuery) validateSubscriptionIds(formats strfmt.Registry) error {

	if swag.IsZero(m.SubscriptionIds) { // not required
		return nil
	}

	for i := 0; i < len(m.SubscriptionIds); i++ {

		if err := validate.FormatOf("subscriptionIds"+"."+strconv.Itoa(i), "body", "uuid", m.SubscriptionIds[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *NotificationsQuery) validateSummary(formats strfmt.Registry) error {

	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	for i := 0; i < len(m.Summary); i++ {
		if swag.IsZero(m.Summary[i]) { // not required
			continue
		}

		if m.Summary[i] != nil {
			if err := m.Summary[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("summary" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *NotificationsQuery) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NotificationsQuery) UnmarshalBinary(b []byte) error {
	var res NotificationsQuery
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
