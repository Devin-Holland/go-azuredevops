// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TimelineTeamData timeline team data
// swagger:model TimelineTeamData
type TimelineTeamData struct {

	// Backlog matching the mapped backlog associated with this team.
	Backlog *BacklogLevel `json:"backlog,omitempty"`

	// The field reference names of the work item data
	FieldReferenceNames []string `json:"fieldReferenceNames"`

	// The id of the team
	// Format: uuid
	ID strfmt.UUID `json:"id,omitempty"`

	// Was iteration and work item data retrieved for this team. <remarks> Teams with IsExpanded false have not had their iteration, work item, and field related data queried and will never contain this data. If true then these items are queried and, if there are items in the queried range, there will be data. </remarks>
	IsExpanded bool `json:"isExpanded,omitempty"`

	// The iteration data, including the work items, in the queried date range.
	Iterations []*TimelineTeamIteration `json:"iterations"`

	// The name of the team
	Name string `json:"name,omitempty"`

	// The order by field name of this team
	OrderByField string `json:"orderByField,omitempty"`

	// The field reference names of the partially paged work items, such as ID, WorkItemType
	PartiallyPagedFieldReferenceNames []string `json:"partiallyPagedFieldReferenceNames"`

	// The project id the team belongs team
	// Format: uuid
	ProjectID strfmt.UUID `json:"projectId,omitempty"`

	// Status for this team.
	Status *TimelineTeamStatus `json:"status,omitempty"`

	// The team field default value
	TeamFieldDefaultValue string `json:"teamFieldDefaultValue,omitempty"`

	// The team field name of this team
	TeamFieldName string `json:"teamFieldName,omitempty"`

	// The team field values
	TeamFieldValues []*TeamFieldValue `json:"teamFieldValues"`

	// Colors for the work item types.
	WorkItemTypeColors []*WorkItemColor `json:"workItemTypeColors"`
}

// Validate validates this timeline team data
func (m *TimelineTeamData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBacklog(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIterations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTeamFieldValues(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWorkItemTypeColors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TimelineTeamData) validateBacklog(formats strfmt.Registry) error {

	if swag.IsZero(m.Backlog) { // not required
		return nil
	}

	if m.Backlog != nil {
		if err := m.Backlog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backlog")
			}
			return err
		}
	}

	return nil
}

func (m *TimelineTeamData) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TimelineTeamData) validateIterations(formats strfmt.Registry) error {

	if swag.IsZero(m.Iterations) { // not required
		return nil
	}

	for i := 0; i < len(m.Iterations); i++ {
		if swag.IsZero(m.Iterations[i]) { // not required
			continue
		}

		if m.Iterations[i] != nil {
			if err := m.Iterations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("iterations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TimelineTeamData) validateProjectID(formats strfmt.Registry) error {

	if swag.IsZero(m.ProjectID) { // not required
		return nil
	}

	if err := validate.FormatOf("projectId", "body", "uuid", m.ProjectID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TimelineTeamData) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *TimelineTeamData) validateTeamFieldValues(formats strfmt.Registry) error {

	if swag.IsZero(m.TeamFieldValues) { // not required
		return nil
	}

	for i := 0; i < len(m.TeamFieldValues); i++ {
		if swag.IsZero(m.TeamFieldValues[i]) { // not required
			continue
		}

		if m.TeamFieldValues[i] != nil {
			if err := m.TeamFieldValues[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("teamFieldValues" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TimelineTeamData) validateWorkItemTypeColors(formats strfmt.Registry) error {

	if swag.IsZero(m.WorkItemTypeColors) { // not required
		return nil
	}

	for i := 0; i < len(m.WorkItemTypeColors); i++ {
		if swag.IsZero(m.WorkItemTypeColors[i]) { // not required
			continue
		}

		if m.WorkItemTypeColors[i] != nil {
			if err := m.WorkItemTypeColors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("workItemTypeColors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TimelineTeamData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TimelineTeamData) UnmarshalBinary(b []byte) error {
	var res TimelineTeamData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
