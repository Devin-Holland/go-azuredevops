// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// QueryHierarchyItem Represents an item in the work item query hierarchy. This can be either a query or a folder.
// swagger:model QueryHierarchyItem
type QueryHierarchyItem struct {
	WorkItemTrackingResource

	// The child query items inside a query folder.
	Children []*QueryHierarchyItem `json:"children"`

	// The clauses for a flat query.
	Clauses *WorkItemQueryClause `json:"clauses,omitempty"`

	// The columns of the query.
	Columns []*WorkItemFieldReference `json:"columns"`

	// The identity who created the query item.
	CreatedBy *IdentityReference `json:"createdBy,omitempty"`

	// When the query item was created.
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// The link query mode.
	// Enum: [workItems linksOneHopMustContain linksOneHopMayContain linksOneHopDoesNotContain linksRecursiveMustContain linksRecursiveMayContain linksRecursiveDoesNotContain]
	FilterOptions interface{} `json:"filterOptions,omitempty"`

	// If this is a query folder, indicates if it contains any children.
	HasChildren bool `json:"hasChildren,omitempty"`

	// The id of the query item.
	// Format: uuid
	ID strfmt.UUID `json:"id,omitempty"`

	// Indicates if this query item is deleted. Setting this to false on a deleted query item will undelete it. Undeleting a query or folder will not bring back the permission changes that were previously applied to it.
	IsDeleted bool `json:"isDeleted,omitempty"`

	// Indicates if this is a query folder or a query.
	IsFolder bool `json:"isFolder,omitempty"`

	// Indicates if the WIQL of this query is invalid. This could be due to invalid syntax or a no longer valid area/iteration path.
	IsInvalidSyntax bool `json:"isInvalidSyntax,omitempty"`

	// Indicates if this query item is public or private.
	IsPublic bool `json:"isPublic,omitempty"`

	// The identity who last ran the query.
	LastExecutedBy *IdentityReference `json:"lastExecutedBy,omitempty"`

	// When the query was last run.
	// Format: date-time
	LastExecutedDate strfmt.DateTime `json:"lastExecutedDate,omitempty"`

	// The identity who last modified the query item.
	LastModifiedBy *IdentityReference `json:"lastModifiedBy,omitempty"`

	// When the query item was last modified.
	// Format: date-time
	LastModifiedDate strfmt.DateTime `json:"lastModifiedDate,omitempty"`

	// The link query clause.
	LinkClauses *WorkItemQueryClause `json:"linkClauses,omitempty"`

	// The name of the query item.
	Name string `json:"name,omitempty"`

	// The path of the query item.
	Path string `json:"path,omitempty"`

	// The recursion option for use in a tree query.
	// Enum: [parentFirst childFirst]
	QueryRecursionOption interface{} `json:"queryRecursionOption,omitempty"`

	// The type of query.
	// Enum: [flat tree oneHop]
	QueryType interface{} `json:"queryType,omitempty"`

	// The sort columns of the query.
	SortColumns []*WorkItemQuerySortColumn `json:"sortColumns"`

	// The source clauses in a tree or one-hop link query.
	SourceClauses *WorkItemQueryClause `json:"sourceClauses,omitempty"`

	// The target clauses in a tree or one-hop link query.
	TargetClauses *WorkItemQueryClause `json:"targetClauses,omitempty"`

	// The WIQL text of the query
	Wiql string `json:"wiql,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *QueryHierarchyItem) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 WorkItemTrackingResource
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.WorkItemTrackingResource = aO0

	// now for regular properties
	var propsQueryHierarchyItem struct {
		Children []*QueryHierarchyItem `json:"children"`

		Clauses *WorkItemQueryClause `json:"clauses,omitempty"`

		Columns []*WorkItemFieldReference `json:"columns"`

		CreatedBy *IdentityReference `json:"createdBy,omitempty"`

		CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

		FilterOptions interface{} `json:"filterOptions,omitempty"`

		HasChildren bool `json:"hasChildren,omitempty"`

		ID strfmt.UUID `json:"id,omitempty"`

		IsDeleted bool `json:"isDeleted,omitempty"`

		IsFolder bool `json:"isFolder,omitempty"`

		IsInvalidSyntax bool `json:"isInvalidSyntax,omitempty"`

		IsPublic bool `json:"isPublic,omitempty"`

		LastExecutedBy *IdentityReference `json:"lastExecutedBy,omitempty"`

		LastExecutedDate strfmt.DateTime `json:"lastExecutedDate,omitempty"`

		LastModifiedBy *IdentityReference `json:"lastModifiedBy,omitempty"`

		LastModifiedDate strfmt.DateTime `json:"lastModifiedDate,omitempty"`

		LinkClauses *WorkItemQueryClause `json:"linkClauses,omitempty"`

		Name string `json:"name,omitempty"`

		Path string `json:"path,omitempty"`

		QueryRecursionOption interface{} `json:"queryRecursionOption,omitempty"`

		QueryType interface{} `json:"queryType,omitempty"`

		SortColumns []*WorkItemQuerySortColumn `json:"sortColumns"`

		SourceClauses *WorkItemQueryClause `json:"sourceClauses,omitempty"`

		TargetClauses *WorkItemQueryClause `json:"targetClauses,omitempty"`

		Wiql string `json:"wiql,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsQueryHierarchyItem); err != nil {
		return err
	}
	m.Children = propsQueryHierarchyItem.Children

	m.Clauses = propsQueryHierarchyItem.Clauses

	m.Columns = propsQueryHierarchyItem.Columns

	m.CreatedBy = propsQueryHierarchyItem.CreatedBy

	m.CreatedDate = propsQueryHierarchyItem.CreatedDate

	m.FilterOptions = propsQueryHierarchyItem.FilterOptions

	m.HasChildren = propsQueryHierarchyItem.HasChildren

	m.ID = propsQueryHierarchyItem.ID

	m.IsDeleted = propsQueryHierarchyItem.IsDeleted

	m.IsFolder = propsQueryHierarchyItem.IsFolder

	m.IsInvalidSyntax = propsQueryHierarchyItem.IsInvalidSyntax

	m.IsPublic = propsQueryHierarchyItem.IsPublic

	m.LastExecutedBy = propsQueryHierarchyItem.LastExecutedBy

	m.LastExecutedDate = propsQueryHierarchyItem.LastExecutedDate

	m.LastModifiedBy = propsQueryHierarchyItem.LastModifiedBy

	m.LastModifiedDate = propsQueryHierarchyItem.LastModifiedDate

	m.LinkClauses = propsQueryHierarchyItem.LinkClauses

	m.Name = propsQueryHierarchyItem.Name

	m.Path = propsQueryHierarchyItem.Path

	m.QueryRecursionOption = propsQueryHierarchyItem.QueryRecursionOption

	m.QueryType = propsQueryHierarchyItem.QueryType

	m.SortColumns = propsQueryHierarchyItem.SortColumns

	m.SourceClauses = propsQueryHierarchyItem.SourceClauses

	m.TargetClauses = propsQueryHierarchyItem.TargetClauses

	m.Wiql = propsQueryHierarchyItem.Wiql

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m QueryHierarchyItem) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(m.WorkItemTrackingResource)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	// now for regular properties
	var propsQueryHierarchyItem struct {
		Children []*QueryHierarchyItem `json:"children"`

		Clauses *WorkItemQueryClause `json:"clauses,omitempty"`

		Columns []*WorkItemFieldReference `json:"columns"`

		CreatedBy *IdentityReference `json:"createdBy,omitempty"`

		CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

		FilterOptions interface{} `json:"filterOptions,omitempty"`

		HasChildren bool `json:"hasChildren,omitempty"`

		ID strfmt.UUID `json:"id,omitempty"`

		IsDeleted bool `json:"isDeleted,omitempty"`

		IsFolder bool `json:"isFolder,omitempty"`

		IsInvalidSyntax bool `json:"isInvalidSyntax,omitempty"`

		IsPublic bool `json:"isPublic,omitempty"`

		LastExecutedBy *IdentityReference `json:"lastExecutedBy,omitempty"`

		LastExecutedDate strfmt.DateTime `json:"lastExecutedDate,omitempty"`

		LastModifiedBy *IdentityReference `json:"lastModifiedBy,omitempty"`

		LastModifiedDate strfmt.DateTime `json:"lastModifiedDate,omitempty"`

		LinkClauses *WorkItemQueryClause `json:"linkClauses,omitempty"`

		Name string `json:"name,omitempty"`

		Path string `json:"path,omitempty"`

		QueryRecursionOption interface{} `json:"queryRecursionOption,omitempty"`

		QueryType interface{} `json:"queryType,omitempty"`

		SortColumns []*WorkItemQuerySortColumn `json:"sortColumns"`

		SourceClauses *WorkItemQueryClause `json:"sourceClauses,omitempty"`

		TargetClauses *WorkItemQueryClause `json:"targetClauses,omitempty"`

		Wiql string `json:"wiql,omitempty"`
	}
	propsQueryHierarchyItem.Children = m.Children

	propsQueryHierarchyItem.Clauses = m.Clauses

	propsQueryHierarchyItem.Columns = m.Columns

	propsQueryHierarchyItem.CreatedBy = m.CreatedBy

	propsQueryHierarchyItem.CreatedDate = m.CreatedDate

	propsQueryHierarchyItem.FilterOptions = m.FilterOptions

	propsQueryHierarchyItem.HasChildren = m.HasChildren

	propsQueryHierarchyItem.ID = m.ID

	propsQueryHierarchyItem.IsDeleted = m.IsDeleted

	propsQueryHierarchyItem.IsFolder = m.IsFolder

	propsQueryHierarchyItem.IsInvalidSyntax = m.IsInvalidSyntax

	propsQueryHierarchyItem.IsPublic = m.IsPublic

	propsQueryHierarchyItem.LastExecutedBy = m.LastExecutedBy

	propsQueryHierarchyItem.LastExecutedDate = m.LastExecutedDate

	propsQueryHierarchyItem.LastModifiedBy = m.LastModifiedBy

	propsQueryHierarchyItem.LastModifiedDate = m.LastModifiedDate

	propsQueryHierarchyItem.LinkClauses = m.LinkClauses

	propsQueryHierarchyItem.Name = m.Name

	propsQueryHierarchyItem.Path = m.Path

	propsQueryHierarchyItem.QueryRecursionOption = m.QueryRecursionOption

	propsQueryHierarchyItem.QueryType = m.QueryType

	propsQueryHierarchyItem.SortColumns = m.SortColumns

	propsQueryHierarchyItem.SourceClauses = m.SourceClauses

	propsQueryHierarchyItem.TargetClauses = m.TargetClauses

	propsQueryHierarchyItem.Wiql = m.Wiql

	jsonDataPropsQueryHierarchyItem, errQueryHierarchyItem := swag.WriteJSON(propsQueryHierarchyItem)
	if errQueryHierarchyItem != nil {
		return nil, errQueryHierarchyItem
	}
	_parts = append(_parts, jsonDataPropsQueryHierarchyItem)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this query hierarchy item
func (m *QueryHierarchyItem) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with WorkItemTrackingResource
	if err := m.WorkItemTrackingResource.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChildren(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClauses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastExecutedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastExecutedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastModifiedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkClauses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceClauses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetClauses(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *QueryHierarchyItem) validateChildren(formats strfmt.Registry) error {

	if swag.IsZero(m.Children) { // not required
		return nil
	}

	for i := 0; i < len(m.Children); i++ {
		if swag.IsZero(m.Children[i]) { // not required
			continue
		}

		if m.Children[i] != nil {
			if err := m.Children[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("children" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *QueryHierarchyItem) validateClauses(formats strfmt.Registry) error {

	if swag.IsZero(m.Clauses) { // not required
		return nil
	}

	if m.Clauses != nil {
		if err := m.Clauses.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clauses")
			}
			return err
		}
	}

	return nil
}

func (m *QueryHierarchyItem) validateColumns(formats strfmt.Registry) error {

	if swag.IsZero(m.Columns) { // not required
		return nil
	}

	for i := 0; i < len(m.Columns); i++ {
		if swag.IsZero(m.Columns[i]) { // not required
			continue
		}

		if m.Columns[i] != nil {
			if err := m.Columns[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("columns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *QueryHierarchyItem) validateCreatedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedBy) { // not required
		return nil
	}

	if m.CreatedBy != nil {
		if err := m.CreatedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createdBy")
			}
			return err
		}
	}

	return nil
}

func (m *QueryHierarchyItem) validateCreatedDate(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *QueryHierarchyItem) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *QueryHierarchyItem) validateLastExecutedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.LastExecutedBy) { // not required
		return nil
	}

	if m.LastExecutedBy != nil {
		if err := m.LastExecutedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastExecutedBy")
			}
			return err
		}
	}

	return nil
}

func (m *QueryHierarchyItem) validateLastExecutedDate(formats strfmt.Registry) error {

	if swag.IsZero(m.LastExecutedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("lastExecutedDate", "body", "date-time", m.LastExecutedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *QueryHierarchyItem) validateLastModifiedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.LastModifiedBy) { // not required
		return nil
	}

	if m.LastModifiedBy != nil {
		if err := m.LastModifiedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastModifiedBy")
			}
			return err
		}
	}

	return nil
}

func (m *QueryHierarchyItem) validateLastModifiedDate(formats strfmt.Registry) error {

	if swag.IsZero(m.LastModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("lastModifiedDate", "body", "date-time", m.LastModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *QueryHierarchyItem) validateLinkClauses(formats strfmt.Registry) error {

	if swag.IsZero(m.LinkClauses) { // not required
		return nil
	}

	if m.LinkClauses != nil {
		if err := m.LinkClauses.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("linkClauses")
			}
			return err
		}
	}

	return nil
}

func (m *QueryHierarchyItem) validateSortColumns(formats strfmt.Registry) error {

	if swag.IsZero(m.SortColumns) { // not required
		return nil
	}

	for i := 0; i < len(m.SortColumns); i++ {
		if swag.IsZero(m.SortColumns[i]) { // not required
			continue
		}

		if m.SortColumns[i] != nil {
			if err := m.SortColumns[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sortColumns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *QueryHierarchyItem) validateSourceClauses(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceClauses) { // not required
		return nil
	}

	if m.SourceClauses != nil {
		if err := m.SourceClauses.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceClauses")
			}
			return err
		}
	}

	return nil
}

func (m *QueryHierarchyItem) validateTargetClauses(formats strfmt.Registry) error {

	if swag.IsZero(m.TargetClauses) { // not required
		return nil
	}

	if m.TargetClauses != nil {
		if err := m.TargetClauses.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("targetClauses")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *QueryHierarchyItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *QueryHierarchyItem) UnmarshalBinary(b []byte) error {
	var res QueryHierarchyItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
