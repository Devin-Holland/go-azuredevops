// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Build Data representation of a build.
// swagger:model Build
type Build struct {

	// links
	Links *ReferenceLinks `json:"_links,omitempty"`

	// The agent specification for the build.
	AgentSpecification *AgentSpecification `json:"agentSpecification,omitempty"`

	// The build number/name of the build.
	BuildNumber string `json:"buildNumber,omitempty"`

	// The build number revision.
	BuildNumberRevision int32 `json:"buildNumberRevision,omitempty"`

	// The build controller. This is only set if the definition type is Xaml.
	Controller *BuildController `json:"controller,omitempty"`

	// The definition associated with the build.
	Definition *DefinitionReference `json:"definition,omitempty"`

	// Indicates whether the build has been deleted.
	Deleted bool `json:"deleted,omitempty"`

	// The identity of the process or person that deleted the build.
	DeletedBy *IdentityRef `json:"deletedBy,omitempty"`

	// The date the build was deleted.
	// Format: date-time
	DeletedDate strfmt.DateTime `json:"deletedDate,omitempty"`

	// The description of how the build was deleted.
	DeletedReason string `json:"deletedReason,omitempty"`

	// A list of demands that represents the agent capabilities required by this build.
	Demands []*Demand `json:"demands"`

	// The time that the build was completed.
	// Format: date-time
	FinishTime strfmt.DateTime `json:"finishTime,omitempty"`

	// The ID of the build.
	ID int32 `json:"id,omitempty"`

	// Indicates whether the build should be skipped by retention policies.
	KeepForever bool `json:"keepForever,omitempty"`

	// The identity representing the process or person that last changed the build.
	LastChangedBy *IdentityRef `json:"lastChangedBy,omitempty"`

	// The date the build was last changed.
	// Format: date-time
	LastChangedDate strfmt.DateTime `json:"lastChangedDate,omitempty"`

	// Information about the build logs.
	Logs *BuildLogReference `json:"logs,omitempty"`

	// The orchestration plan for the build.
	OrchestrationPlan *TaskOrchestrationPlanReference `json:"orchestrationPlan,omitempty"`

	// The parameters for the build.
	Parameters string `json:"parameters,omitempty"`

	// Orchestration plans associated with the build (build, cleanup)
	Plans []*TaskOrchestrationPlanReference `json:"plans"`

	// The build's priority.
	// Enum: [low belowNormal normal aboveNormal high]
	Priority interface{} `json:"priority,omitempty"`

	// The team project.
	Project *TeamProjectReference `json:"project,omitempty"`

	// properties
	Properties *PropertiesCollection `json:"properties,omitempty"`

	// The quality of the xaml build (good, bad, etc.)
	Quality string `json:"quality,omitempty"`

	// The queue. This is only set if the definition type is Build.
	Queue *AgentPoolQueue `json:"queue,omitempty"`

	// Additional options for queueing the build.
	// Enum: [none doNotRun]
	QueueOptions interface{} `json:"queueOptions,omitempty"`

	// The current position of the build in the queue.
	QueuePosition int32 `json:"queuePosition,omitempty"`

	// The time that the build was queued.
	// Format: date-time
	QueueTime strfmt.DateTime `json:"queueTime,omitempty"`

	// The reason that the build was created.
	// Enum: [none manual individualCI batchedCI schedule scheduleForced userCreated validateShelveset checkInShelveset pullRequest buildCompletion triggered all]
	Reason interface{} `json:"reason,omitempty"`

	// The repository.
	Repository *BuildRepository `json:"repository,omitempty"`

	// The identity that queued the build.
	RequestedBy *IdentityRef `json:"requestedBy,omitempty"`

	// The identity on whose behalf the build was queued.
	RequestedFor *IdentityRef `json:"requestedFor,omitempty"`

	// The build result.
	// Enum: [none succeeded partiallySucceeded failed canceled]
	Result interface{} `json:"result,omitempty"`

	// Indicates whether the build is retained by a release.
	RetainedByRelease bool `json:"retainedByRelease,omitempty"`

	// The source branch.
	SourceBranch string `json:"sourceBranch,omitempty"`

	// The source version.
	SourceVersion string `json:"sourceVersion,omitempty"`

	// The time that the build was started.
	// Format: date-time
	StartTime strfmt.DateTime `json:"startTime,omitempty"`

	// The status of the build.
	// Enum: [none inProgress completed cancelling postponed notStarted all]
	Status interface{} `json:"status,omitempty"`

	// tags
	Tags []string `json:"tags"`

	// Sourceprovider-specific information about what triggered the build
	TriggerInfo map[string]string `json:"triggerInfo,omitempty"`

	// The build that triggered this build via a Build completion trigger.
	TriggeredByBuild *Build `json:"triggeredByBuild,omitempty"`

	// The URI of the build.
	URI string `json:"uri,omitempty"`

	// The REST URL of the build.
	URL string `json:"url,omitempty"`

	// validation results
	ValidationResults []*BuildRequestValidationResult `json:"validationResults"`
}

// Validate validates this build
func (m *Build) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAgentSpecification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateController(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefinition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeletedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeletedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDemands(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinishTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastChangedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastChangedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrchestrationPlan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlans(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProject(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueueTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRepository(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestedFor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggeredByBuild(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationResults(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Build) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateAgentSpecification(formats strfmt.Registry) error {

	if swag.IsZero(m.AgentSpecification) { // not required
		return nil
	}

	if m.AgentSpecification != nil {
		if err := m.AgentSpecification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("agentSpecification")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateController(formats strfmt.Registry) error {

	if swag.IsZero(m.Controller) { // not required
		return nil
	}

	if m.Controller != nil {
		if err := m.Controller.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controller")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateDefinition(formats strfmt.Registry) error {

	if swag.IsZero(m.Definition) { // not required
		return nil
	}

	if m.Definition != nil {
		if err := m.Definition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("definition")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateDeletedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.DeletedBy) { // not required
		return nil
	}

	if m.DeletedBy != nil {
		if err := m.DeletedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("deletedBy")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateDeletedDate(formats strfmt.Registry) error {

	if swag.IsZero(m.DeletedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("deletedDate", "body", "date-time", m.DeletedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Build) validateDemands(formats strfmt.Registry) error {

	if swag.IsZero(m.Demands) { // not required
		return nil
	}

	for i := 0; i < len(m.Demands); i++ {
		if swag.IsZero(m.Demands[i]) { // not required
			continue
		}

		if m.Demands[i] != nil {
			if err := m.Demands[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("demands" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Build) validateFinishTime(formats strfmt.Registry) error {

	if swag.IsZero(m.FinishTime) { // not required
		return nil
	}

	if err := validate.FormatOf("finishTime", "body", "date-time", m.FinishTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Build) validateLastChangedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.LastChangedBy) { // not required
		return nil
	}

	if m.LastChangedBy != nil {
		if err := m.LastChangedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastChangedBy")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateLastChangedDate(formats strfmt.Registry) error {

	if swag.IsZero(m.LastChangedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("lastChangedDate", "body", "date-time", m.LastChangedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Build) validateLogs(formats strfmt.Registry) error {

	if swag.IsZero(m.Logs) { // not required
		return nil
	}

	if m.Logs != nil {
		if err := m.Logs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("logs")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateOrchestrationPlan(formats strfmt.Registry) error {

	if swag.IsZero(m.OrchestrationPlan) { // not required
		return nil
	}

	if m.OrchestrationPlan != nil {
		if err := m.OrchestrationPlan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("orchestrationPlan")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validatePlans(formats strfmt.Registry) error {

	if swag.IsZero(m.Plans) { // not required
		return nil
	}

	for i := 0; i < len(m.Plans); i++ {
		if swag.IsZero(m.Plans[i]) { // not required
			continue
		}

		if m.Plans[i] != nil {
			if err := m.Plans[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("plans" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Build) validateProject(formats strfmt.Registry) error {

	if swag.IsZero(m.Project) { // not required
		return nil
	}

	if m.Project != nil {
		if err := m.Project.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("project")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateProperties(formats strfmt.Registry) error {

	if swag.IsZero(m.Properties) { // not required
		return nil
	}

	if m.Properties != nil {
		if err := m.Properties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("properties")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateQueue(formats strfmt.Registry) error {

	if swag.IsZero(m.Queue) { // not required
		return nil
	}

	if m.Queue != nil {
		if err := m.Queue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("queue")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateQueueTime(formats strfmt.Registry) error {

	if swag.IsZero(m.QueueTime) { // not required
		return nil
	}

	if err := validate.FormatOf("queueTime", "body", "date-time", m.QueueTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Build) validateRepository(formats strfmt.Registry) error {

	if swag.IsZero(m.Repository) { // not required
		return nil
	}

	if m.Repository != nil {
		if err := m.Repository.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("repository")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateRequestedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestedBy) { // not required
		return nil
	}

	if m.RequestedBy != nil {
		if err := m.RequestedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("requestedBy")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateRequestedFor(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestedFor) { // not required
		return nil
	}

	if m.RequestedFor != nil {
		if err := m.RequestedFor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("requestedFor")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateStartTime(formats strfmt.Registry) error {

	if swag.IsZero(m.StartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("startTime", "body", "date-time", m.StartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Build) validateTriggeredByBuild(formats strfmt.Registry) error {

	if swag.IsZero(m.TriggeredByBuild) { // not required
		return nil
	}

	if m.TriggeredByBuild != nil {
		if err := m.TriggeredByBuild.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("triggeredByBuild")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateValidationResults(formats strfmt.Registry) error {

	if swag.IsZero(m.ValidationResults) { // not required
		return nil
	}

	for i := 0; i < len(m.ValidationResults); i++ {
		if swag.IsZero(m.ValidationResults[i]) { // not required
			continue
		}

		if m.ValidationResults[i] != nil {
			if err := m.ValidationResults[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validationResults" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Build) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Build) UnmarshalBinary(b []byte) error {
	var res Build
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
