// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LicenseSummaryData Summary of Licenses in the organization.
// swagger:model LicenseSummaryData
type LicenseSummaryData struct {
	SummaryData

	// Type of Account License.
	// Enum: [none earlyAdopter express professional advanced stakeholder]
	AccountLicenseType interface{} `json:"accountLicenseType,omitempty"`

	// Count of Disabled Licenses.
	Disabled int32 `json:"disabled,omitempty"`

	// Designates if this license quantity can be changed through purchase
	IsPurchasable bool `json:"isPurchasable,omitempty"`

	// Name of the License.
	LicenseName string `json:"licenseName,omitempty"`

	// Type of MSDN License.
	// Enum: [none eligible professional platforms testProfessional premium ultimate enterprise]
	MsdnLicenseType interface{} `json:"msdnLicenseType,omitempty"`

	// Specifies the date when billing will charge for paid licenses
	// Format: date-time
	NextBillingDate strfmt.DateTime `json:"nextBillingDate,omitempty"`

	// Source of the License.
	// Enum: [none account msdn profile auto trial]
	Source interface{} `json:"source,omitempty"`

	// Total license count after next billing cycle
	TotalAfterNextBillingDate int32 `json:"totalAfterNextBillingDate,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *LicenseSummaryData) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 SummaryData
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.SummaryData = aO0

	// now for regular properties
	var propsLicenseSummaryData struct {
		AccountLicenseType interface{} `json:"accountLicenseType,omitempty"`

		Disabled int32 `json:"disabled,omitempty"`

		IsPurchasable bool `json:"isPurchasable,omitempty"`

		LicenseName string `json:"licenseName,omitempty"`

		MsdnLicenseType interface{} `json:"msdnLicenseType,omitempty"`

		NextBillingDate strfmt.DateTime `json:"nextBillingDate,omitempty"`

		Source interface{} `json:"source,omitempty"`

		TotalAfterNextBillingDate int32 `json:"totalAfterNextBillingDate,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsLicenseSummaryData); err != nil {
		return err
	}
	m.AccountLicenseType = propsLicenseSummaryData.AccountLicenseType

	m.Disabled = propsLicenseSummaryData.Disabled

	m.IsPurchasable = propsLicenseSummaryData.IsPurchasable

	m.LicenseName = propsLicenseSummaryData.LicenseName

	m.MsdnLicenseType = propsLicenseSummaryData.MsdnLicenseType

	m.NextBillingDate = propsLicenseSummaryData.NextBillingDate

	m.Source = propsLicenseSummaryData.Source

	m.TotalAfterNextBillingDate = propsLicenseSummaryData.TotalAfterNextBillingDate

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m LicenseSummaryData) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(m.SummaryData)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	// now for regular properties
	var propsLicenseSummaryData struct {
		AccountLicenseType interface{} `json:"accountLicenseType,omitempty"`

		Disabled int32 `json:"disabled,omitempty"`

		IsPurchasable bool `json:"isPurchasable,omitempty"`

		LicenseName string `json:"licenseName,omitempty"`

		MsdnLicenseType interface{} `json:"msdnLicenseType,omitempty"`

		NextBillingDate strfmt.DateTime `json:"nextBillingDate,omitempty"`

		Source interface{} `json:"source,omitempty"`

		TotalAfterNextBillingDate int32 `json:"totalAfterNextBillingDate,omitempty"`
	}
	propsLicenseSummaryData.AccountLicenseType = m.AccountLicenseType

	propsLicenseSummaryData.Disabled = m.Disabled

	propsLicenseSummaryData.IsPurchasable = m.IsPurchasable

	propsLicenseSummaryData.LicenseName = m.LicenseName

	propsLicenseSummaryData.MsdnLicenseType = m.MsdnLicenseType

	propsLicenseSummaryData.NextBillingDate = m.NextBillingDate

	propsLicenseSummaryData.Source = m.Source

	propsLicenseSummaryData.TotalAfterNextBillingDate = m.TotalAfterNextBillingDate

	jsonDataPropsLicenseSummaryData, errLicenseSummaryData := swag.WriteJSON(propsLicenseSummaryData)
	if errLicenseSummaryData != nil {
		return nil, errLicenseSummaryData
	}
	_parts = append(_parts, jsonDataPropsLicenseSummaryData)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this license summary data
func (m *LicenseSummaryData) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with SummaryData
	if err := m.SummaryData.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNextBillingDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicenseSummaryData) validateNextBillingDate(formats strfmt.Registry) error {

	if swag.IsZero(m.NextBillingDate) { // not required
		return nil
	}

	if err := validate.FormatOf("nextBillingDate", "body", "date-time", m.NextBillingDate.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LicenseSummaryData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicenseSummaryData) UnmarshalBinary(b []byte) error {
	var res LicenseSummaryData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
