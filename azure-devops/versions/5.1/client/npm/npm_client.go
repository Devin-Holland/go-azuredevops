// Code generated by go-swagger; DO NOT EDIT.

package npm

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new npm API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for npm API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DeletePackageVersionFromRecycleBin Delete a package version without an npm scope from the recycle bin.
*/
func (a *Client) DeletePackageVersionFromRecycleBin(params *DeletePackageVersionFromRecycleBinParams, authInfo runtime.ClientAuthInfoWriter) (*DeletePackageVersionFromRecycleBinOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePackageVersionFromRecycleBinParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Delete Package Version From Recycle Bin",
		Method:             "DELETE",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/{packageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeletePackageVersionFromRecycleBinReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeletePackageVersionFromRecycleBinOK), nil

}

/*
DeleteScopedPackageVersionFromRecycleBin Delete a package version with an npm scope from the recycle bin.
*/
func (a *Client) DeleteScopedPackageVersionFromRecycleBin(params *DeleteScopedPackageVersionFromRecycleBinParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteScopedPackageVersionFromRecycleBinOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteScopedPackageVersionFromRecycleBinParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Delete Scoped Package Version From Recycle Bin",
		Method:             "DELETE",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteScopedPackageVersionFromRecycleBinReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteScopedPackageVersionFromRecycleBinOK), nil

}

/*
DownloadPackage Get an unscoped npm package.
*/
func (a *Client) DownloadPackage(params *DownloadPackageParams, authInfo runtime.ClientAuthInfoWriter) (*DownloadPackageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadPackageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DownloadPackage",
		Method:             "GET",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/packages/{packageName}/versions/{packageVersion}/content",
		ProducesMediaTypes: []string{"application/octet-stream"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadPackageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DownloadPackageOK), nil

}

/*
DownloadScopedPackage download scoped package API
*/
func (a *Client) DownloadScopedPackage(params *DownloadScopedPackageParams, authInfo runtime.ClientAuthInfoWriter) (*DownloadScopedPackageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadScopedPackageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DownloadScopedPackage",
		Method:             "GET",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}/content",
		ProducesMediaTypes: []string{"application/octet-stream"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadScopedPackageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DownloadScopedPackageOK), nil

}

/*
GetPackageReadme Get the Readme for a package version that has no npm scope.
*/
func (a *Client) GetPackageReadme(params *GetPackageReadmeParams, authInfo runtime.ClientAuthInfoWriter) (*GetPackageReadmeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPackageReadmeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPackageReadme",
		Method:             "GET",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/packages/{packageName}/versions/{packageVersion}/readme",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPackageReadmeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPackageReadmeOK), nil

}

/*
GetPackageVersion Get information about an unscoped package version.
*/
func (a *Client) GetPackageVersion(params *GetPackageVersionParams, authInfo runtime.ClientAuthInfoWriter) (*GetPackageVersionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPackageVersionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPackageVersion",
		Method:             "GET",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/{packageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPackageVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPackageVersionOK), nil

}

/*
GetPackageVersionFromRecycleBin Get information about an unscoped package version in the recycle bin.
*/
func (a *Client) GetPackageVersionFromRecycleBin(params *GetPackageVersionFromRecycleBinParams, authInfo runtime.ClientAuthInfoWriter) (*GetPackageVersionFromRecycleBinOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPackageVersionFromRecycleBinParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPackageVersionFromRecycleBin",
		Method:             "GET",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/{packageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPackageVersionFromRecycleBinReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPackageVersionFromRecycleBinOK), nil

}

/*
GetScopedPackageReadme Get the Readme for a package version with an npm scope.
*/
func (a *Client) GetScopedPackageReadme(params *GetScopedPackageReadmeParams, authInfo runtime.ClientAuthInfoWriter) (*GetScopedPackageReadmeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScopedPackageReadmeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetScopedPackageReadme",
		Method:             "GET",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}/readme",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScopedPackageReadmeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScopedPackageReadmeOK), nil

}

/*
GetScopedPackageVersion Get information about a scoped package version (such as @scope/name).
*/
func (a *Client) GetScopedPackageVersion(params *GetScopedPackageVersionParams, authInfo runtime.ClientAuthInfoWriter) (*GetScopedPackageVersionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScopedPackageVersionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetScopedPackageVersion",
		Method:             "GET",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScopedPackageVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScopedPackageVersionOK), nil

}

/*
GetScopedPackageVersionFromRecycleBin Get information about a scoped package version in the recycle bin.
*/
func (a *Client) GetScopedPackageVersionFromRecycleBin(params *GetScopedPackageVersionFromRecycleBinParams, authInfo runtime.ClientAuthInfoWriter) (*GetScopedPackageVersionFromRecycleBinOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScopedPackageVersionFromRecycleBinParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetScopedPackageVersionFromRecycleBin",
		Method:             "GET",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScopedPackageVersionFromRecycleBinReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScopedPackageVersionFromRecycleBinOK), nil

}

/*
RestorePackageVersionFromRecycleBin Restore a package version without an npm scope from the recycle bin to its feed.
*/
func (a *Client) RestorePackageVersionFromRecycleBin(params *RestorePackageVersionFromRecycleBinParams, authInfo runtime.ClientAuthInfoWriter) (*RestorePackageVersionFromRecycleBinOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRestorePackageVersionFromRecycleBinParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Restore Package Version From Recycle Bin",
		Method:             "PATCH",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/{packageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RestorePackageVersionFromRecycleBinReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RestorePackageVersionFromRecycleBinOK), nil

}

/*
RestoreScopedPackageVersionFromRecycleBin Restore a package version with an npm scope from the recycle bin to its feed.
*/
func (a *Client) RestoreScopedPackageVersionFromRecycleBin(params *RestoreScopedPackageVersionFromRecycleBinParams, authInfo runtime.ClientAuthInfoWriter) (*RestoreScopedPackageVersionFromRecycleBinOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRestoreScopedPackageVersionFromRecycleBinParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Restore Scoped Package Version From Recycle Bin",
		Method:             "PATCH",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RestoreScopedPackageVersionFromRecycleBinReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RestoreScopedPackageVersionFromRecycleBinOK), nil

}

/*
UnpublishPackage Unpublish an unscoped package version.
*/
func (a *Client) UnpublishPackage(params *UnpublishPackageParams, authInfo runtime.ClientAuthInfoWriter) (*UnpublishPackageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnpublishPackageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Unpublish Package",
		Method:             "DELETE",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/{packageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnpublishPackageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UnpublishPackageOK), nil

}

/*
UnpublishScopedPackage Unpublish a scoped package version (such as @scope/name).
*/
func (a *Client) UnpublishScopedPackage(params *UnpublishScopedPackageParams, authInfo runtime.ClientAuthInfoWriter) (*UnpublishScopedPackageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnpublishScopedPackageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Unpublish Scoped Package",
		Method:             "DELETE",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnpublishScopedPackageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UnpublishScopedPackageOK), nil

}

/*
UpdatePackage update package API
*/
func (a *Client) UpdatePackage(params *UpdatePackageParams, authInfo runtime.ClientAuthInfoWriter) (*UpdatePackageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePackageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Update Package",
		Method:             "PATCH",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/{packageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdatePackageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdatePackageOK), nil

}

/*
UpdatePackages Update several packages from a single feed in a single request. The updates to the packages do not happen atomically.
*/
func (a *Client) UpdatePackages(params *UpdatePackagesParams, authInfo runtime.ClientAuthInfoWriter) (*UpdatePackagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePackagesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Update Packages",
		Method:             "POST",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/packagesbatch",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdatePackagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdatePackagesOK), nil

}

/*
UpdateScopedPackage update scoped package API
*/
func (a *Client) UpdateScopedPackage(params *UpdateScopedPackageParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateScopedPackageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateScopedPackageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Update Scoped Package",
		Method:             "PATCH",
		PathPattern:        "/{organization}/_apis/packaging/feeds/{feedId}/npm/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateScopedPackageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateScopedPackageOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
