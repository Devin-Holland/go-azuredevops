// Code generated by go-swagger; DO NOT EDIT.

package builds

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new builds API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for builds API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
GetBuildChanges Gets the changes associated with a build
*/
func (a *Client) GetBuildChanges(params *GetBuildChangesParams, authInfo runtime.ClientAuthInfoWriter) (*GetBuildChangesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBuildChangesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Get Build Changes",
		Method:             "GET",
		PathPattern:        "/{organization}/{project}/_apis/build/builds/{buildId}/changes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetBuildChangesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBuildChangesOK), nil

}

/*
GetBuildLog Gets an individual log file for a build.
*/
func (a *Client) GetBuildLog(params *GetBuildLogParams, authInfo runtime.ClientAuthInfoWriter) (*GetBuildLogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBuildLogParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Get Build Log",
		Method:             "GET",
		PathPattern:        "/{organization}/{project}/_apis/build/builds/{buildId}/logs/{logId}",
		ProducesMediaTypes: []string{"application/json", "application/zip", "text/plain"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetBuildLogReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBuildLogOK), nil

}

/*
GetBuildLogs Gets the logs for a build.
*/
func (a *Client) GetBuildLogs(params *GetBuildLogsParams, authInfo runtime.ClientAuthInfoWriter) (*GetBuildLogsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBuildLogsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Get Build Logs",
		Method:             "GET",
		PathPattern:        "/{organization}/{project}/_apis/build/builds/{buildId}/logs",
		ProducesMediaTypes: []string{"application/json", "application/zip"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetBuildLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBuildLogsOK), nil

}

/*
GetBuildWorkItemsRefs Gets the work items associated with a build.
*/
func (a *Client) GetBuildWorkItemsRefs(params *GetBuildWorkItemsRefsParams, authInfo runtime.ClientAuthInfoWriter) (*GetBuildWorkItemsRefsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBuildWorkItemsRefsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Get Build Work Items Refs",
		Method:             "GET",
		PathPattern:        "/{organization}/{project}/_apis/build/builds/{buildId}/workitems",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetBuildWorkItemsRefsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBuildWorkItemsRefsOK), nil

}

/*
GetBuildWorkItemsRefsFromCommits Gets the work items associated with a build, filtered to specific commits.
*/
func (a *Client) GetBuildWorkItemsRefsFromCommits(params *GetBuildWorkItemsRefsFromCommitsParams, authInfo runtime.ClientAuthInfoWriter) (*GetBuildWorkItemsRefsFromCommitsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBuildWorkItemsRefsFromCommitsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Get Build Work Items Refs From Commits",
		Method:             "POST",
		PathPattern:        "/{organization}/{project}/_apis/build/builds/{buildId}/workitems",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetBuildWorkItemsRefsFromCommitsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBuildWorkItemsRefsFromCommitsOK), nil

}

/*
GetChangesBetweenBuilds Gets the changes made to the repository between two given builds.
*/
func (a *Client) GetChangesBetweenBuilds(params *GetChangesBetweenBuildsParams, authInfo runtime.ClientAuthInfoWriter) (*GetChangesBetweenBuildsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetChangesBetweenBuildsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Get Changes Between Builds",
		Method:             "GET",
		PathPattern:        "/{organization}/{project}/_apis/build/changes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetChangesBetweenBuildsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetChangesBetweenBuildsOK), nil

}

/*
GetWorkItemsBetweenBuilds Gets all the work items between two builds.
*/
func (a *Client) GetWorkItemsBetweenBuilds(params *GetWorkItemsBetweenBuildsParams, authInfo runtime.ClientAuthInfoWriter) (*GetWorkItemsBetweenBuildsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetWorkItemsBetweenBuildsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Get Work Items Between Builds",
		Method:             "GET",
		PathPattern:        "/{organization}/{project}/_apis/build/workitems",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetWorkItemsBetweenBuildsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetWorkItemsBetweenBuildsOK), nil

}

/*
Queue Queues a build
*/
func (a *Client) Queue(params *QueueParams, authInfo runtime.ClientAuthInfoWriter) (*QueueOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQueueParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Queue",
		Method:             "POST",
		PathPattern:        "/{organization}/{project}/_apis/build/builds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &QueueReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*QueueOK), nil

}

/*
UpdateBuild Updates a build.
*/
func (a *Client) UpdateBuild(params *UpdateBuildParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateBuildOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateBuildParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Update Build",
		Method:             "PATCH",
		PathPattern:        "/{organization}/{project}/_apis/build/builds/{buildId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateBuildReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateBuildOK), nil

}

/*
UpdateBuilds Updates multiple builds.
*/
func (a *Client) UpdateBuilds(params *UpdateBuildsParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateBuildsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateBuildsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Update Builds",
		Method:             "PATCH",
		PathPattern:        "/{organization}/{project}/_apis/build/builds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateBuildsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateBuildsOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
